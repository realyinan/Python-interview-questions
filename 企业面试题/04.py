# 假设你使用的是官方的CPython，说出下面代码的运行结果

a, b, c, d = 1, 1, 1000, 1000
print(a is b, c is d)  # True False
print('*'*100)

def foo():
    e = 1000
    f = 1000
    print(e is f, e is d)  # False False
    g = 1
    print(g is a)  # True
foo()
print('*'*100)

# Python 对小整数（通常在 -5 到 256 范围内）的处理有一个优化：在这个范围内的整数对象是预先分配的，并且会被重用。这意味着每次你创建一个在这个范围内的整数时，实际上都会引用同一个对象。这种优化可以提高性能，因为这些数字在程序中被频繁使用。

# 对于超过这个范围的整数（即大整数），Python 不会缓存它们。每次你创建一个大整数对象时，都会创建一个新的对象。因此，即使两个大整数的值相同，它们也会是不同的对象。
 
# 对于较短的字符串（尤其是符合标识符规则的字符串，例如变量名），Python 会自动进行驻留处理，即将字符串存储在一个全局表中，并重用这些字符串。这种优化有助于节省内存并加快字符串比较操作。

# 在编译时，如果某些字符串是常量（在代码中多次出现相同的字符串字面量），Python 可能会将它们缓存起来。

# 对于在运行时动态生成的字符串（例如通过字符串操作创建的新字符串），则不一定会被缓存

a = "hello" + " world"
b = "hello world"
print(a is b)  # 可能输出 False，因为动态生成的字符串不一定被驻留
print('*'*100)

# 浮点数在 Python 中通常不会进行缓存。每次创建一个浮点数对象时，都会创建一个新的对象，即使它们的值相同。
a = 3.14
b = 3.14
print(a is b)  # 输出 False，浮点数不会被缓存
print('*'*100)

# 元组是不可变的序列类型，对于空元组和包含相同元素的小元组，Python 也会进行缓存。较大的元组或包含可变对象的元组通常不会被缓存。
a = ()
b = ()
print(a is b)  # 输出 True，空元组被缓存

c = (1, 2, 3)
d = (1, 2, 3)
print(c is d)  # 可能输出 True 或 False，取决于实现
print('*'*100)

list1 = [1, 2, 3]
list2 = [1, 2, 3]
print(list1 is list2)

# Python中变量在内存中的存储方式

# 不可变类型: int float str tuple
# 可变类型: list dict set

# 不可变类型
s = 'hello'
print(id(s))  # 2772222315312
s2 = 'hello'
print(id(s2))  # 2772222315312
s2 = 'hello2'
print(id(s2))  # 2772222315184
print('*'*100)

# 可变类型
list1 = [1, 2, 3]
print(id(list1))  # 2947212348800
list1.append(4)  
print(id(list1))  # # 2947212348800
print('*'*100)

list1 = [1, 2, 3]
print(id(list1))  # 2574260597632
list2 = [1, 2, 3]
print(id(list2))  # 2574259817856


### 不可变类型（Immutable Types）

#### 不可变类型的存储方式
# 1. **值的不可变性**：不可变对象的值在创建后不能修改。如果对一个不可变对象进行修改操作，会创建一个新的对象，并将该对象的引用返回给变量。
# 2. **内存优化**：由于不可变对象的值不会改变，Python 会对一些小的或常用的不可变对象进行缓存和重用。例如，小整数对象和 interned 字符串。

a = 10
b = 10
print(a is b)  # True, 因为小整数对象被缓存重用

s1 = "hello"
s2 = "hello"
print(s1 is s2)  # True, 因为字符串被缓存和重用

### 可变类型（Mutable Types）

#### 可变类型的存储方式
# 1. **引用的共享**：可变对象的变量实际上是对象的引用。如果多个变量引用同一个可变对象，通过其中一个变量对对象进行修改，其他引用该对象的变量也会感受到变化。
# 2. **直接修改内容**：对可变对象进行修改操作时，不会创建新的对象，而是直接在原对象上进行修改。

lst1 = [1, 2, 3]
lst2 = lst1
lst2.append(4)
print(lst1)  # [1, 2, 3, 4], 因为 lst1 和 lst2 引用的是同一个列表对象

d1 = {'key': 'value'}
d2 = d1
d2['key'] = 'new_value'
print(d1)  # {'key': 'new_value'}, 因为 d1 和 d2 引用的是同一个字典对象

### 内存模型
# - **不可变对象**：当你对不可变对象进行修改操作时，实际上是创建了一个新的对象，并将新对象的引用赋给变量。旧对象如果没有其他引用，会被垃圾回收机制回收。
x = 10
print(id(x))  # 输出 x 的内存地址
x += 1
print(id(x))  # 输出新的内存地址，因为 x 现在引用的是一个新的对象

# - **可变对象**：对可变对象进行修改时，内存地址不变，因为修改操作是在原对象上进行的。

lst = [1, 2, 3]
print(id(lst))  # 输出 lst 的内存地址
lst.append(4)
print(id(lst))  # 内存地址不变，表示修改是在原对象上进行的

### 总结
# 1. **不可变对象**在内存中的值一旦创建就不能改变。对其进行修改操作会创建一个新的对象，并将变量指向新对象。Python 对一些常用的不可变对象进行缓存和重用，以优化内存使用。
# 2. **可变对象**在内存中的值可以改变。对其进行修改操作时，会直接修改对象本身，而不会创建新的对象。这种行为使得多个变量可以共享一个可变对象的引用，修改一个变量会影响所有引用该对象的变量。

